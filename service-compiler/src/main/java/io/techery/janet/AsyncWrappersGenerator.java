package io.techery.janet;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Types;

import io.techery.janet.async.annotations.Payload;
import io.techery.janet.async.annotations.Response;
import io.techery.janet.compiler.utils.Generator;
import io.techery.janet.internal.TypeToken;

public class AsyncWrappersGenerator extends Generator<AsyncActionClass> {

    private final Types typeUtils;

    protected AsyncWrappersGenerator(Filer filer, Types typeUtils) {
        super(filer);
        this.typeUtils = typeUtils;
    }

    @Override
    public void generate(ArrayList<AsyncActionClass> actionClasses) {
        for (AsyncActionClass actionClass : actionClasses) {
            generate(actionClass);
        }
    }

    private void generate(AsyncActionClass actionClass) {
        //create header
        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(actionClass.getWrapperName())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addJavadoc("Janet compile time, autogenerated class")
                .addTypeVariables(getTypeVariables(actionClass.getTypeElement()))
                .superclass(ParameterizedTypeName.get(ClassName.get(AsyncActionWrapper.class), actionClass.getTypeName()))
                .addMethod(MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(ParameterizedTypeName.get(ClassName.get(ActionHolder.class), actionClass.getTypeName()), "holder")
                        .addStatement("super(holder)")
                        .build())
                .addMethod(createGetEventMethod(actionClass))
                .addMethod(createIsBytesPayloadMethod(actionClass))
                .addMethod(createGetPayloadFieldTypeMethod(actionClass))
                .addMethod(createGetPayloadMethod(actionClass))
                .addMethod(createSetPayloadMethod(actionClass))
                .addMethod(createGetResponseFieldTypeMethod(actionClass))
                .addMethod(createSetResponseMethod(actionClass))
                .addMethod(createGetResponseTimeoutMethod(actionClass));

        saveClass(actionClass.getPackageName(), classBuilder.build());
    }

    private static MethodSpec createIsBytesPayloadMethod(AsyncActionClass actionClass) {
        return MethodSpec.methodBuilder("isBytesPayload")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(boolean.class)
                .addStatement("return $L", actionClass.isBytesPayload())
                .build();
    }

    private static MethodSpec createGetEventMethod(AsyncActionClass actionClass) {
        return MethodSpec.methodBuilder("getEvent")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return $S", actionClass.getEvent())
                .build();
    }

    private MethodSpec createGetPayloadFieldTypeMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getPayloadFieldType")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(Type.class);
        Element field = getAnnotatedElement(actionClass, Payload.class);
        if (field != null) {
            builder.addStatement("return new $T<$T>(){}.getType()",
                    TypeToken.class, getElementTypeName(actionClass, field));
        } else {
            builder.addStatement("return null");
        }
        return builder.build();
    }

    private static MethodSpec createGetPayloadMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getPayload")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(Object.class);
        Element field = getAnnotatedElement(actionClass, Payload.class);
        if (field != null) {
            builder.addStatement("return action.$L", field);
        } else {
            builder.addStatement("return null");
        }
        return builder.build();
    }

    private MethodSpec createSetPayloadMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("setPayload")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(Object.class, "payload");
        Element field = getAnnotatedElement(actionClass, Payload.class);
        if (field != null) {
            builder.addStatement("action.$L = ($T) payload", field, getElementTypeName(actionClass, field));
        } else {
            builder.addStatement("//do nothing");
        }
        return builder.build();
    }

    private MethodSpec createGetResponseFieldTypeMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getResponseFieldType")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(Type.class);
        Element field = getAnnotatedElement(actionClass, Response.class);
        if (field != null) {
            builder.addStatement("return new $T<$T>(){}.getType()",
                    TypeToken.class, getElementTypeName(actionClass, field));
        } else {
            builder.addStatement("return null");
        }
        return builder.build();
    }


    private MethodSpec createSetResponseMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("setResponse")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(Object.class, "response");
        Element field = getAnnotatedElement(actionClass, Response.class);
        if (field != null) {
            builder.addStatement("action.$L = ($T) response", field, getElementTypeName(actionClass, field));
        } else {
            builder.addStatement("//do nothing");
        }
        return builder.build();
    }

    private static MethodSpec createGetResponseTimeoutMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getResponseTimeout")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(long.class);
        long timeout = 0L;
        Element field = getAnnotatedElement(actionClass, Response.class);
        if (field != null) {
            timeout = field.getAnnotation(Response.class).timeout();
        }
        if (timeout > 0) {
            builder.addStatement("return $Ll", timeout);
        } else {
            builder.addStatement("return super.getResponseTimeout()");
        }
        return builder.build();
    }

    private TypeName getElementTypeName(AsyncActionClass actionClass, Element element) {
        if (element.asType().getKind() == TypeKind.TYPEVAR) {
            TypeParameterElement typeElement = (TypeParameterElement) typeUtils.asElement(element.asType());

            ParameterizedTypeName genericElementTypeName = (ParameterizedTypeName) TypeName.get(typeElement.getGenericElement()
                    .asType());

            int typeArgIndex;
            for (typeArgIndex = 0; typeArgIndex < genericElementTypeName.typeArguments.size(); typeArgIndex++) {
                if (genericElementTypeName.typeArguments.get(typeArgIndex).toString()
                        .equals(element.asType().toString())) {
                    break;
                }
            }

            TypeMirror superClassType = actionClass.getTypeElement().getSuperclass();
            while (!TypeName.get(superClassType).toString().startsWith(genericElementTypeName.rawType.toString())) {
                TypeElement superClassElement = (TypeElement) typeUtils.asElement(superClassType);
                superClassType = superClassElement.getSuperclass();
            }
            return ((ParameterizedTypeName) TypeName.get(superClassType)).typeArguments.get(typeArgIndex);
        } else {
            return ClassName.get((TypeElement) typeUtils.asElement(element.asType()));
        }
    }

    private static Iterable<TypeVariableName> getTypeVariables(TypeElement element) {
        List<TypeVariableName> typeVariables = new ArrayList<TypeVariableName>();
        for (TypeParameterElement type : element.getTypeParameters()) {
            typeVariables.add((TypeVariableName) TypeVariableName.get(type.asType()));
        }
        return typeVariables;
    }

    private static Element getAnnotatedElement(AsyncActionClass actionClass, Class anotationClass) {
        List<Element> fields = actionClass.getAnnotatedElements(anotationClass);
        if (!fields.isEmpty()) {
            return fields.get(0);
        }
        return null;
    }

}
